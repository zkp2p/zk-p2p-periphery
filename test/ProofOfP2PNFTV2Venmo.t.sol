// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import { Test, console2 } from "forge-std/Test.sol";
import { IRamp } from "../src/interfaces/IRamp.sol";
import { MockRamp } from "../src/mocks/MockRamp.sol";
import { ProofOfP2PNFTV2Venmo } from "../src/ProofOfP2PNFTV2Venmo.sol";

contract ProofOfP2PNFTV2VenmoTest is Test {
    ProofOfP2PNFTV2Venmo public proofOfP2PNFTV2Venmo;
    MockRamp public ramp;

    function setUp() public {
        ramp = new MockRamp();

        // Register user 0x1
        ramp.setAccountInfo(
            address(1),
            IRamp.AccountInfo({
                venmoIdHash: bytes32(0x0741728e3aae72eda484e8ccbf00f843c38eae9c399b9bd7fb2b5ee7a055b6bf),
                deposits: new uint256[](0)
            })
        );

        proofOfP2PNFTV2Venmo = new ProofOfP2PNFTV2Venmo(ramp);
    }
    
    function test_Mint() public {
        uint256 prevMinted = proofOfP2PNFTV2Venmo.getTokenId(address(1));
        assertEq(prevMinted, 0);

        vm.startPrank(address(1));
        proofOfP2PNFTV2Venmo.mintSBT();
        vm.stopPrank();
        
        uint256 tokenId = proofOfP2PNFTV2Venmo.currentTokenId();
        assertEq(tokenId, 1);

        address owner = proofOfP2PNFTV2Venmo.ownerOf(tokenId);
        assertEq(owner, address(1));

        uint256 balance = proofOfP2PNFTV2Venmo.balanceOf(address(1));
        assertEq(balance, 1);

        uint256 currMinted = proofOfP2PNFTV2Venmo.getTokenId(address(1));
        assertEq(currMinted, 1);

        string memory tokenURI = proofOfP2PNFTV2Venmo.tokenURI(tokenId);
        string memory expectedTokenURI = "data:application/json;base64,eyJuYW1lIjoiUHJvb2Ygb2YgVmVubW8iLCAiZGVzY3JpcHRpb24iOiJUaGlzIHNvdWxib3VuZCBORlQgcmVwcmVzZW50cyBwcm9vZiB0aGF0IHlvdSBhcmUgYSB1bmlxdWUgVmVubW8gdXNlci4gTWludCB0aGlzIGJ5IGdlbmVyYXRpbmcgYSB6ZXJvIGtub3dsZWRnZSBwcm9vZiBvZiBhIHBheW1lbnQgY29uZmlybWF0aW9uIGVtYWlsLiBZb3VyIGlkZW50aWZpZXIgaXMgaGFzaGVkLCBzbyBubyBvbmUga25vd3Mgd2hvIHlvdSBhcmUgLS0gb25seSB0aGF0IHlvdSBhcmUgYW4gdXNlciFcblxuSGFzaGVkIElEOiAweDA3NDE3MjhlM2FhZTcyZWRhNDg0ZThjY2JmMDBmODQzYzM4ZWFlOWMzOTliOWJkN2ZiMmI1ZWU3YTA1NWI2YmZcblxuIiwgImltYWdlIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qa3dJaUJvWldsbmFIUTlJalF5TUNJZ2RtbGxkMEp2ZUQwaU1DQXdJREk1TUNBME1qQWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SjJoMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zblBqeGtaV1p6UGp4bWFXeDBaWElnYVdROUltWXhJajQ4Wm1WSmJXRm5aU0J5WlhOMWJIUTlJbkF3SWlCNGJHbHVhenBvY21WbVBTSmtZWFJoT21sdFlXZGxMM04yWnl0NGJXdzdZbUZ6WlRZMExGQklUakphZVVJellWZFNNR0ZFTUc1TmFtdDNTbmxDYjFwWGJHNWhTRkU1U25wUmVVMURZMmRrYld4c1pEQktkbVZFTUc1TlEwRjNTVVJKTlUxRFFUQk5ha0Z1U1Vob2RHSkhOWHBRVTJSdlpFaFNkMDlwT0haa00yUXpURzVqZWt4dE9YbGFlVGg1VFVSQmQwd3pUakphZVdNclVFaEtiRmt6VVdka01teHJaRWRuT1VwNlNUVk5TRUkwU25sQ2IxcFhiRzVoU0ZFNVNucFJlVTFJUWpSS2VVSnRZVmQ0YzFCVFkycE5NRWw2VDBSc1JVcDVPQ3RRUXpsNlpHMWpLeUl2UGp4bVpVbHRZV2RsSUhKbGMzVnNkRDBpY0RFaUlIaHNhVzVyT21oeVpXWTlJbVJoZEdFNmFXMWhaMlV2YzNabkszaHRiRHRpWVhObE5qUXNVRWhPTWxwNVFqTmhWMUl3WVVRd2JrMXFhM2RLZVVKdldsZHNibUZJVVRsS2VsRjVUVU5qWjJSdGJHeGtNRXAyWlVRd2JrMURRWGRKUkVrMVRVTkJNRTFxUVc1SlNHaDBZa2MxZWxCVFpHOWtTRkozVDJrNGRtUXpaRE5NYm1ONlRHMDVlVnA1T0hsTlJFRjNURE5PTWxwNVl5dFFSMDV3WTIxT2MxcFRRbXBsUkRCdVRWUkJlVXA1UW1wbFZEQnVUVlJCZDBwNVFubFFVMk40VFdwQ2QyVkRZMmRhYld4ellrUXdia2t3V1hwT2ExRXlUVU5qZGxCcWQzWmpNMXB1VUdjOVBTSXZQanhtWlVsdFlXZGxJSEpsYzNWc2REMGljRElpSUhoc2FXNXJPbWh5WldZOUltUmhkR0U2YVcxaFoyVXZjM1puSzNodGJEdGlZWE5sTmpRc1VFaE9NbHA1UWpOaFYxSXdZVVF3YmsxcWEzZEtlVUp2V2xkc2JtRklVVGxLZWxGNVRVTmpaMlJ0Ykd4a01FcDJaVVF3YmsxRFFYZEpSRWsxVFVOQk1FMXFRVzVKU0doMFlrYzFlbEJUWkc5a1NGSjNUMms0ZG1RelpETk1ibU42VEcwNWVWcDVPSGxOUkVGM1RETk9NbHA1WXl0UVIwNXdZMjFPYzFwVFFtcGxSREJ1VFdwUk5VcDVRbXBsVkRCdVRWUkJkMHA1UW5sUVUyTjRUV3BDZDJWRFkyZGFiV3h6WWtRd2JrbDZUa2RQVkUwd1RubGpkbEJxZDNaak0xcHVVR2M5UFNJZ0x6NDhabVZKYldGblpTQnlaWE4xYkhROUluQXpJaUI0YkdsdWF6cG9jbVZtUFNKa1lYUmhPbWx0WVdkbEwzTjJaeXQ0Yld3N1ltRnpaVFkwTEZCSVRqSmFlVUl6WVZkU01HRkVNRzVOYW10M1NubENiMXBYYkc1aFNGRTVTbnBSZVUxRFkyZGtiV3hzWkRCS2RtVkVNRzVOUTBGM1NVUkpOVTFEUVRCTmFrRnVTVWhvZEdKSE5YcFFVMlJ2WkVoU2QwOXBPSFprTTJRelRHNWpla3h0T1hsYWVUaDVUVVJCZDB3elRqSmFlV01yVUVkT2NHTnRUbk5hVTBKcVpVUXdiazVVYTI1SlIwNDFVRk5qZUUxRVFXNUpTRWs1U25wRmQwMUlRalJLZVVKdFlWZDRjMUJUWTJwT2VrbDRVV3BqTkVwNU9DdFFRemw2Wkcxakt5SWdMejQ4Wm1WQ2JHVnVaQ0J0YjJSbFBTSnZkbVZ5YkdGNUlpQnBiajBpY0RBaUlHbHVNajBpY0RFaUlDOCtQR1psUW14bGJtUWdiVzlrWlQwaVpYaGpiSFZ6YVc5dUlpQnBiakk5SW5BeUlpQXZQanhtWlVKc1pXNWtJRzF2WkdVOUltOTJaWEpzWVhraUlHbHVNajBpY0RNaUlISmxjM1ZzZEQwaVlteGxibVJQZFhRaUlDOCtQR1psUjJGMWMzTnBZVzVDYkhWeUlHbHVQU0ppYkdWdVpFOTFkQ0lnYzNSa1JHVjJhV0YwYVc5dVBTSTBNaUlnTHo0OEwyWnBiSFJsY2o0Z1BHTnNhWEJRWVhSb0lHbGtQU0pqYjNKdVpYSnpJajQ4Y21WamRDQjNhV1IwYUQwaU1qa3dJaUJvWldsbmFIUTlJalF5TUNJZ2NuZzlJalF5SWlCeWVUMGlORElpSUM4K1BDOWpiR2x3VUdGMGFENDhjR0YwYUNCcFpEMGlkR1Y0ZEMxd1lYUm9MV0VpSUdROUlrMDBNQ0F4TWlCSU1qVXdJRUV5T0NBeU9DQXdJREFnTVNBeU56Z2dOREFnVmpNNE1DQkJNamdnTWpnZ01DQXdJREVnTWpVd0lEUXdPQ0JJTkRBZ1FUSTRJREk0SURBZ01DQXhJREV5SURNNE1DQldOREFnUVRJNElESTRJREFnTUNBeElEUXdJREV5SUhvaUlDOCtQSEJoZEdnZ2FXUTlJbTFwYm1sdFlYQWlJR1E5SWsweU16UWdORFEwUXpJek5DQTBOVGN1T1RRNUlESTBNaTR5TVNBME5qTWdNalV6SURRMk15SWdMejQ4Wm1sc2RHVnlJR2xrUFNKMGIzQXRjbVZuYVc5dUxXSnNkWElpUGp4bVpVZGhkWE56YVdGdVFteDFjaUJwYmowaVUyOTFjbU5sUjNKaGNHaHBZeUlnYzNSa1JHVjJhV0YwYVc5dVBTSXlOQ0lnTHo0OEwyWnBiSFJsY2o0OGJHbHVaV0Z5UjNKaFpHbGxiblFnYVdROUltZHlZV1F0ZFhBaUlIZ3hQU0l4SWlCNE1qMGlNQ0lnZVRFOUlqRWlJSGt5UFNJd0lqNDhjM1J2Y0NCdlptWnpaWFE5SWpBdU1DSWdjM1J2Y0MxamIyeHZjajBpZDJocGRHVWlJSE4wYjNBdGIzQmhZMmwwZVQwaU1TSWdMejQ4YzNSdmNDQnZabVp6WlhROUlpNDVJaUJ6ZEc5d0xXTnZiRzl5UFNKM2FHbDBaU0lnYzNSdmNDMXZjR0ZqYVhSNVBTSXdJaUF2UGp3dmJHbHVaV0Z5UjNKaFpHbGxiblErUEd4cGJtVmhja2R5WVdScFpXNTBJR2xrUFNKbmNtRmtMV1J2ZDI0aUlIZ3hQU0l3SWlCNE1qMGlNU0lnZVRFOUlqQWlJSGt5UFNJeElqNDhjM1J2Y0NCdlptWnpaWFE5SWpBdU1DSWdjM1J2Y0MxamIyeHZjajBpZDJocGRHVWlJSE4wYjNBdGIzQmhZMmwwZVQwaU1TSWdMejQ4YzNSdmNDQnZabVp6WlhROUlqQXVPU0lnYzNSdmNDMWpiMnh2Y2owaWQyaHBkR1VpSUhOMGIzQXRiM0JoWTJsMGVUMGlNQ0lnTHo0OEwyeHBibVZoY2tkeVlXUnBaVzUwUGp4dFlYTnJJR2xrUFNKbVlXUmxMWFZ3SWlCdFlYTnJRMjl1ZEdWdWRGVnVhWFJ6UFNKdlltcGxZM1JDYjNWdVpHbHVaMEp2ZUNJK1BISmxZM1FnZDJsa2RHZzlJakVpSUdobGFXZG9kRDBpTVNJZ1ptbHNiRDBpZFhKc0tDTm5jbUZrTFhWd0tTSWdMejQ4TDIxaGMycytQRzFoYzJzZ2FXUTlJbVpoWkdVdFpHOTNiaUlnYldGemEwTnZiblJsYm5SVmJtbDBjejBpYjJKcVpXTjBRbTkxYm1ScGJtZENiM2dpUGp4eVpXTjBJSGRwWkhSb1BTSXhJaUJvWldsbmFIUTlJakVpSUdacGJHdzlJblZ5YkNnalozSmhaQzFrYjNkdUtTSWdMejQ4TDIxaGMycytQRzFoYzJzZ2FXUTlJbTV2Ym1VaUlHMWhjMnREYjI1MFpXNTBWVzVwZEhNOUltOWlhbVZqZEVKdmRXNWthVzVuUW05NElqNDhjbVZqZENCM2FXUjBhRDBpTVNJZ2FHVnBaMmgwUFNJeElpQm1hV3hzUFNKM2FHbDBaU0lnTHo0OEwyMWhjMnMrUEd4cGJtVmhja2R5WVdScFpXNTBJR2xrUFNKbmNtRmtMWE41YldKdmJDSStQSE4wYjNBZ2IyWm1jMlYwUFNJd0xqY2lJSE4wYjNBdFkyOXNiM0k5SW5kb2FYUmxJaUJ6ZEc5d0xXOXdZV05wZEhrOUlqRWlJQzgrUEhOMGIzQWdiMlptYzJWMFBTSXVPVFVpSUhOMGIzQXRZMjlzYjNJOUluZG9hWFJsSWlCemRHOXdMVzl3WVdOcGRIazlJakFpSUM4K1BDOXNhVzVsWVhKSGNtRmthV1Z1ZEQ0OGJXRnpheUJwWkQwaVptRmtaUzF6ZVcxaWIyd2lJRzFoYzJ0RGIyNTBaVzUwVlc1cGRITTlJblZ6WlhKVGNHRmpaVTl1VlhObElqNDhjbVZqZENCM2FXUjBhRDBpTWprd2NIZ2lJR2hsYVdkb2REMGlNakF3Y0hnaUlHWnBiR3c5SW5WeWJDZ2paM0poWkMxemVXMWliMndwSWlBdlBqd3ZiV0Z6YXo0OEwyUmxabk0rUEdjZ1kyeHBjQzF3WVhSb1BTSjFjbXdvSTJOdmNtNWxjbk1wSWo0OGNtVmpkQ0JtYVd4c1BTSXpRak00T1VRaUlIZzlJakJ3ZUNJZ2VUMGlNSEI0SWlCM2FXUjBhRDBpTWprd2NIZ2lJR2hsYVdkb2REMGlOREl3Y0hnaUlDOCtQSEpsWTNRZ2MzUjViR1U5SW1acGJIUmxjam9nZFhKc0tDTm1NU2tpSUhnOUlqQndlQ0lnZVQwaU1IQjRJaUIzYVdSMGFEMGlNamt3Y0hnaUlHaGxhV2RvZEQwaU5ESXdjSGdpSUM4K0lEeG5JSE4wZVd4bFBTSm1hV3gwWlhJNmRYSnNLQ04wYjNBdGNtVm5hVzl1TFdKc2RYSXBPeUIwY21GdWMyWnZjbTA2YzJOaGJHVW9NUzQxS1RzZ2RISmhibk5tYjNKdExXOXlhV2RwYmpwalpXNTBaWElnZEc5d095SStQSEpsWTNRZ1ptbHNiRDBpYm05dVpTSWdlRDBpTUhCNElpQjVQU0l3Y0hnaUlIZHBaSFJvUFNJeU9UQndlQ0lnYUdWcFoyaDBQU0kwTWpCd2VDSWdMejQ4Wld4c2FYQnpaU0JqZUQwaU5UQWxJaUJqZVQwaU1IQjRJaUJ5ZUQwaU1UZ3djSGdpSUhKNVBTSXhNakJ3ZUNJZ1ptbHNiRDBpTTBJek9EbEVJaUJ2Y0dGamFYUjVQU0l3SWlBdlBqd3ZaejQ4Y21WamRDQjRQU0l3SWlCNVBTSXdJaUIzYVdSMGFEMGlNamt3SWlCb1pXbG5hSFE5SWpReU1DSWdjbmc5SWpReUlpQnllVDBpTkRJaUlHWnBiR3c5SW5KblltRW9NQ3d3TERBc01Da2lJSE4wY205clpUMGljbWRpWVNneU5UVXNNalUxTERJMU5Td3dMaklwSWlBdlBqd3ZaejQ4ZEdWNGRDQjBaWGgwTFhKbGJtUmxjbWx1WnowaWIzQjBhVzFwZW1WVGNHVmxaQ0krUEhSbGVIUlFZWFJvSUhOMFlYSjBUMlptYzJWMFBTSXRNVEF3SlNJZ1ptbHNiRDBpZDJocGRHVWlJR1p2Ym5RdFptRnRhV3g1UFNJblEyOTFjbWxsY2lCT1pYY25MQ0J0YjI1dmMzQmhZMlVpSUdadmJuUXRjMmw2WlQwaU1UQndlQ0lnZUd4cGJtczZhSEpsWmowaUkzUmxlSFF0Y0dGMGFDMWhJajVJWVhOb0lPS0FvaUF3ZURBM05ERTNNamhsTTJGaFpUY3laV1JoTkRnMFpUaGpZMkptTURCbU9EUXpZek00WldGbE9XTXpPVGxpT1dKa04yWmlNbUkxWldVM1lUQTFOV0kyWW1ZZ1BHRnVhVzFoZEdVZ1lXUmthWFJwZG1VOUluTjFiU0lnWVhSMGNtbGlkWFJsVG1GdFpUMGljM1JoY25SUFptWnpaWFFpSUdaeWIyMDlJakFsSWlCMGJ6MGlNVEF3SlNJZ1ltVm5hVzQ5SWpCeklpQmtkWEk5SWpNd2N5SWdjbVZ3WldGMFEyOTFiblE5SW1sdVpHVm1hVzVwZEdVaUlDOCtQQzkwWlhoMFVHRjBhRDRnUEhSbGVIUlFZWFJvSUhOMFlYSjBUMlptYzJWMFBTSXdKU0lnWm1sc2JEMGlkMmhwZEdVaUlHWnZiblF0Wm1GdGFXeDVQU0luUTI5MWNtbGxjaUJPWlhjbkxDQnRiMjV2YzNCaFkyVWlJR1p2Ym5RdGMybDZaVDBpTVRCd2VDSWdlR3hwYm1zNmFISmxaajBpSTNSbGVIUXRjR0YwYUMxaElqNUlZWE5vSU9LQW9pQXdlREEzTkRFM01qaGxNMkZoWlRjeVpXUmhORGcwWlRoalkySm1NREJtT0RRell6TTRaV0ZsT1dNek9UbGlPV0prTjJaaU1tSTFaV1UzWVRBMU5XSTJZbVlnUEdGdWFXMWhkR1VnWVdSa2FYUnBkbVU5SW5OMWJTSWdZWFIwY21saWRYUmxUbUZ0WlQwaWMzUmhjblJQWm1aelpYUWlJR1p5YjIwOUlqQWxJaUIwYnowaU1UQXdKU0lnWW1WbmFXNDlJakJ6SWlCa2RYSTlJak13Y3lJZ2NtVndaV0YwUTI5MWJuUTlJbWx1WkdWbWFXNXBkR1VpSUM4K0lEd3ZkR1Y0ZEZCaGRHZytQSFJsZUhSUVlYUm9JSE4wWVhKMFQyWm1jMlYwUFNJMU1DVWlJR1pwYkd3OUluZG9hWFJsSWlCbWIyNTBMV1poYldsc2VUMGlKME52ZFhKcFpYSWdUbVYzSnl3Z2JXOXViM053WVdObElpQm1iMjUwTFhOcGVtVTlJakV3Y0hnaUlIaHNhVzVyT21oeVpXWTlJaU4wWlhoMExYQmhkR2d0WVNJK1QzZHVaWElnNG9DaUlEQjRNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TVNBOFlXNXBiV0YwWlNCaFpHUnBkR2wyWlQwaWMzVnRJaUJoZEhSeWFXSjFkR1ZPWVcxbFBTSnpkR0Z5ZEU5bVpuTmxkQ0lnWm5KdmJUMGlNQ1VpSUhSdlBTSXhNREFsSWlCaVpXZHBiajBpTUhNaUlHUjFjajBpTXpCeklpQnlaWEJsWVhSRGIzVnVkRDBpYVc1a1pXWnBibWwwWlNJZ0x6NDhMM1JsZUhSUVlYUm9QangwWlhoMFVHRjBhQ0J6ZEdGeWRFOW1abk5sZEQwaUxUVXdKU0lnWm1sc2JEMGlkMmhwZEdVaUlHWnZiblF0Wm1GdGFXeDVQU0luUTI5MWNtbGxjaUJPWlhjbkxDQnRiMjV2YzNCaFkyVWlJR1p2Ym5RdGMybDZaVDBpTVRCd2VDSWdlR3hwYm1zNmFISmxaajBpSTNSbGVIUXRjR0YwYUMxaElqNVBkMjVsY2lEaWdLSWdNSGd3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBeElEeGhibWx0WVhSbElHRmtaR2wwYVhabFBTSnpkVzBpSUdGMGRISnBZblYwWlU1aGJXVTlJbk4wWVhKMFQyWm1jMlYwSWlCbWNtOXRQU0l3SlNJZ2RHODlJakV3TUNVaUlHSmxaMmx1UFNJd2N5SWdaSFZ5UFNJek1ITWlJSEpsY0dWaGRFTnZkVzUwUFNKcGJtUmxabWx1YVhSbElpQXZQand2ZEdWNGRGQmhkR2crUEM5MFpYaDBQanhuSUhOMGVXeGxQU0owY21GdWMyWnZjbTA2ZEhKaGJuTnNZWFJsS0RFd05YQjRMQ0EzTUhCNEtTSStQSE4yWnlCM2FXUjBhRDBpT0RVaUlHaGxhV2RvZEQwaU9EVWlJSFpwWlhkQ2IzZzlJakFnTUNBeE9USWdNVGt5SWlCbWFXeHNQU0p1YjI1bElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaVBqeHdZWFJvSUdROUlrMHhNVE11TnpRMklERXhPQzR6T1RaRE1URTBMakEyTnlBeE1UZ3VNemsySURFeU15NDFNakVnTVRFM0xqWXhOaUF4TWpjdU16YzJJREV4Tmk0NU1qaERNVFV4TGpRM01TQXhNVEV1TVRRMUlERTJPUzQwTVRZZ09Ea3VNemt4TWlBeE5qa3VOREUySURZekxqTTJPVEZETVRZNUxqUTJNaUF6TWk0NU5ERXlJREUwTkM0NU1EZ2dPQzR5T1RVNE9TQXhNVFF1TmpZMElEZ3VNamsxT0RsRE1URTBMak0wTWlBNExqSTVOVGc1SURFeE5DNHdOamNnT0M0eU9UVTRPU0F4TVRNdU56UTJJRGd1TWprMU9EbElNVEUwTGpZMk5FZ3hNVFl1TnpJNVF6RXhOUzQwT1NBNExqSTVOVGc1SURFeE5DNHlPVGNnT0M0eU5TQXhNVE11TURFeElEZ3VNalZJTlRJdU5qWXdORU16Tmk0eU16QXpJRGd1TWpVZ01qSXVPRGMxSURJeExqWXdOVE1nTWpJdU9EYzFJRE00TGpBek5UUldNVFU0TGpJek0wTXlNaTQ0TnpVZ01UY3lMak15TWlBek5DNHpNREkzSURFNE15NDNOU0EwT0M0ek9USXpJREU0TXk0M05VTTJOQzR6TmpNMUlERTRNeTQzTlNBM055NHpOVEUySURFM01DNDRNRGdnTnpjdU16VXhOaUF4TlRRdU56a3hWakV5TXk0eE5qbEROemN1TXpVeE5pQXhNakF1TmpRMUlEYzVMalF4TmpnZ01URTRMalU0SURneExqazBNU0F4TVRndU5UaElNVEEzTGpBME5VTXhNRGt1TnpVeklERXhPQzQxT0NBeE1UTXVOelEySURFeE9DNHpOVEVnTVRFekxqYzBOaUF4TVRndU16VXhWakV4T0M0ek9UWmFJaUJtYVd4c1BTSjFjbXdvSTNCaGFXNTBNRjlzYVc1bFlYSmZNalUwWHpJMk56a3BJaTgrUEhCaGRHZ2daRDBpVFRJeUxqVWdNemN1TnpVM09Vd3lNeTR3TURNNElERTBOaTQyTWpWRE16SXVNekF4TXlBeE1UVXVNemMySURVekxqY3pOaUF4TURjdU5UUXhJRGcyTGpNNU1Ua2dNVEUxTGpZd05VTTVNeTR5TmpJZ01URTNMalUzTlNBNU9DNDJNakEySURFeE9DNHlNVGNnTVRBekxqSTVNaUF4TVRndU5FZ3hNRFl1TkRrNFF6RXdPUzR5TURFZ01URTRMalFnTVRFekxqRTROU0F4TVRndU1UY3hJREV4TXk0eE9EVWdNVEU0TGpFM01VTXhNVE11TlRBMklERXhPQzR4TnpFZ01USXlMamswTVNBeE1UY3VNemt5SURFeU5pNDNPRGdnTVRFMkxqY3dOVU14TXpBdU5UUTBJREV4TlM0M09EZ2dNVE0wTGpFMk1pQXhNVFF1TkRZZ01UTTNMalUxTVNBeE1USXVPREZETVRRMExqYzRPQ0F4TURndU9UWXhJREUxTUM0Mk9UWWdNVEF6TGpjNE5DQXhOVFF1TkRBMklERXdNQzR6TURGRE1UVTVMamcxTmlBNU5DNHlPVGt4SURFMk5DNHdNalFnT0RjdU1EVTVOeUF4TmpZdU5EQTJJRGM1TGpBNE56RkRNVFkzTGpZNE9DQTNNeTQ0TmpNMklERTJPQzR6TnpVZ05qZ3VNVE0yTWlBeE5qZ3VNemMxSURZeExqazFNRFpETVRZNExqTTNOU0ExT1M0M05URXlJREUyT0M0eU9ETWdOVGN1TlRrM055QXhOamd1TVRRMklEVTFMalE1UXpFMk5DNDNNVEVnTXpFdU1ESXlOQ0F4TkRVdU16TTNJREV4TGpjM09ESWdNVEl3TGpnNElEZ3VOelUwTVRORE1USXdMakExTlNBNExqWTJNalE1SURFeE9TNHlNekVnT0M0MU56QTROaUF4TVRndU16WXhJRGd1TlRJMU1EUkRNVEUzTGpZM05DQTRMalEzT1RJeUlERXhOaTQ1T0RjZ09DNDBNek0wSURFeE5pNHpJRGd1TkRNek5FTXhNVFF1TlRFeklEZ3VNelF4TnpZZ01URXlMalk0TVNBNExqSTFNREV5SURFeE1DNDRNRFFnT0M0eU5UQXhNa2cxTWk0eU1qUTJRek0xTGpnM016Z2dPQzR5TURReklESXlMalU1TVRZZ01qRXVOREl3TXlBeU1pNDFJRE0zTGpjMU56bGFJaUJtYVd4c1BTSjFjbXdvSTNCaGFXNTBNVjlzYVc1bFlYSmZNalUwWHpJMk56a3BJaTgrUEhCaGRHZ2daRDBpVFRFd05pNDJOamNnT1RrdU16WXlPRU14TWpBdU9EQTBJREV3TXk0ME5UVWdNVE14TGpVME15QXhNRFV1TURBM0lERXpPUzQ0TXprZ01UQTFMakF3TjBNeE5EUXVPRFkwSURFd05TNHdNRGNnTVRRNExqazRPQ0F4TURRdU5ETTJJREUxTWk0ME1qTWdNVEF6TGpVeE0wTXhOakl1T1RNNElEa3pMalExTnpJZ01UWTVMalVnTnprdU1qWXhNeUF4TmprdU5TQTJNeTQxTWpNM1F6RTJPUzQxTURVZ016TXVNRE13TVNBeE5EUXVPVEF4SURndU16QTROamdnTVRFMExqVTFOeUE0TGpNd09EWTRRekV4TkM0eU5UTWdPQzR6TURnMk9DQXhNVE11T1RRNUlEZ3VNekUwTURJZ01URXpMalkwTlNBNExqTXhPVE0xVmpndU16QTROamhJTVRFMkxqWTFORU14TVRVdU5ETXlJRGd1TWpjeE16UWdNVEUwTGpFNE9TQTRMakkxSURFeE1pNDVNeUE0TGpJMVNEVXlMak0zTkRoRE16VXVPRGMwTXlBNExqSTFJREl5TGpVZ01qRXVOakkwTXlBeU1pNDFJRE00TGpFeU5EaFdPVGt1TVRBeE5FTTBNaTQxTXpjMUlEYzJMak00TURVZ056TXVOamczTXlBNE55NDFNelUySURFd05pNDJOamNnT1RrdU16WXlPRm9pSUdacGJHdzlJblZ5YkNnamNHRnBiblF5WDJ4cGJtVmhjbDh5TlRSZk1qWTNPU2tpTHo0OGNHRjBhQ0JrUFNKTk1UQTJMalE0TlNBMU1DNHlOVEk1UXpFeU1DNDFPRElnTlRRdU16STFNU0F4TXpFdU1qZ3hJRFUxTGpnNE1EZ2dNVE01TGpVNU1pQTFOUzQ0T0RBNFF6RTFOQzQ1TnpRZ05UVXVPRGd3T0NBeE5qRXVPVEE0SURVd0xqVTNNeklnTVRZMkxqVWdORFl1TWpJMk5VTXhOVGt1TXpNM0lESTBMakl4T0RRZ01UTTRMalkzTXlBNExqSTVOVGMxSURFeE5DNHpNemNnT0M0eU9UVTNOVU14TVRRdU1ERTFJRGd1TWprMU56VWdNVEV6TGpjMElEZ3VNamsxTnpVZ01URXpMalF4T0NBNExqSTVOVGMxU0RFeE5DNHpNemRJTVRFMkxqUXdNME14TVRVdU1UWXpJRGd1TWprMU56VWdNVEV6TGprMk9TQTRMakkxSURFeE1pNDJPRFFnT0M0eU5VZzFNaTR6TURGRE16VXVPRFl5TWlBNExqSTFJREl5TGpVZ01qRXVOVFkwTnlBeU1pNDFJRE0zTGprME5EbFdOVEF1TURJME1rTTBNaTQwTnpRMUlESTNMalF5TVRNZ056TXVOVFl4TWlBek9DNDFNemszSURFd05pNDBPRFVnTlRBdU1qazROMVkxTUM0eU5USTVXaUlnWm1sc2JEMGlkWEpzS0NOd1lXbHVkRE5mYkdsdVpXRnlYekkxTkY4eU5qYzVLU0l2UGp4d1lYUm9JR1E5SWsweE1EY3VOakl4SURJeExqUXpNelJETVRJeExqUXlOeUF5TlM0ME5qVTBJREV6TVM0NU1EVWdNamN1TURBMU55QXhOREF1TURRMUlESTNMakF3TlRkRE1UUTFMamd3TWlBeU55NHdNRFUzSURFMU1DNHlOVFFnTWpZdU1Ua3dNeUF4TlRNdU9UUXlJREkxTGpBeE1qUkRNVFExTGpZeU1pQXhOaTR5TmpnNElERXpOQzQxTVRRZ01UQXVNamc0TnlBeE1qRXVPVFkzSURndU56UTRNelJETVRJeExqRTFOeUE0TGpZMU56Y3pJREV5TUM0ek5EZ2dPQzQxTmpjeE15QXhNVGt1TkRreklEZ3VOVEl4T0RKRE1URTRMamd4T1NBNExqUTNOalV5SURFeE9DNHhORFFnT0M0ME16RXlNU0F4TVRjdU5EWTVJRGd1TkRNeE1qRkRNVEUxTGpjeE5pQTRMak0wTURZeElERXhNeTQ1TVRjZ09DNHlOU0F4TVRJdU1EY3pJRGd1TWpWSU5UUXVOVFV6TlVNMU15NDNORFFnT0M0eU5TQTFNaTQ1TXpRMUlEZ3VNamsxTXlBMU1pNHhNalVnT0M0ek9EVTVNVU0yT0M0MU16azRJRGN1TXpnNU1qTWdPRGN1TnpReU9TQXhOQzR5TnpVMElERXdOeTQyTWpFZ01qRXVORGM0TjFZeU1TNDBNek0wV2lJZ1ptbHNiRDBpZFhKc0tDTndZV2x1ZERSZmJHbHVaV0Z5WHpJMU5GOHlOamM1S1NJdlBqeGtaV1p6UGp4c2FXNWxZWEpIY21Ga2FXVnVkQ0JwWkQwaWNHRnBiblF3WDJ4cGJtVmhjbDh5TlRSZk1qWTNPU0lnZURFOUlqSXlMamczTlNJZ2VURTlJamcwTGpnMU1EZ2lJSGd5UFNJeE5qa3VOREUySWlCNU1qMGlPRFF1T0RVd09DSWdaM0poWkdsbGJuUlZibWwwY3owaWRYTmxjbE53WVdObFQyNVZjMlVpUGp4emRHOXdJSE4wYjNBdFkyOXNiM0k5SWlNME1EVTNRMElpTHo0OGMzUnZjQ0J2Wm1aelpYUTlJakF1TVRrMk9UY2lJSE4wYjNBdFkyOXNiM0k5SWlNelF6TkJPVVlpTHo0OGMzUnZjQ0J2Wm1aelpYUTlJakF1TlRRMU5EVTFJaUJ6ZEc5d0xXTnZiRzl5UFNJak5EUXhOVGN4SWk4K1BITjBiM0FnYjJabWMyVjBQU0l4SWlCemRHOXdMV052Ykc5eVBTSWpNamd4UXpOQklpOCtQQzlzYVc1bFlYSkhjbUZrYVdWdWRENDhiR2x1WldGeVIzSmhaR2xsYm5RZ2FXUTlJbkJoYVc1ME1WOXNhVzVsWVhKZk1qVTBYekkyTnpraUlIZ3hQU0l5T0M0d01qVTJJaUI1TVQwaU5qUXVOak0wSWlCNE1qMGlNVGN6TGprd01TSWdlVEk5SWpZMExqWXpOQ0lnWjNKaFpHbGxiblJWYm1sMGN6MGlkWE5sY2xOd1lXTmxUMjVWYzJVaVBqeHpkRzl3SUhOMGIzQXRZMjlzYjNJOUlpTTNPREZETjBFaUx6NDhjM1J2Y0NCdlptWnpaWFE5SWpFaUlITjBiM0F0WTI5c2IzSTlJaU0xTlRFMk56RWlMejQ4TDJ4cGJtVmhja2R5WVdScFpXNTBQanhzYVc1bFlYSkhjbUZrYVdWdWRDQnBaRDBpY0dGcGJuUXlYMnhwYm1WaGNsOHlOVFJmTWpZM09TSWdlREU5SWpJeUxqVWlJSGt4UFNJMk9TNHdOalkxSWlCNE1qMGlNVFk1TGpjMElpQjVNajBpTmprdU1EWTJOU0lnWjNKaFpHbGxiblJWYm1sMGN6MGlkWE5sY2xOd1lXTmxUMjVWYzJVaVBqeHpkRzl3SUc5bVpuTmxkRDBpTUM0eE5UazBNaUlnYzNSdmNDMWpiMnh2Y2owaUkwWkZPRUUyTnlJdlBqeHpkRzl3SUc5bVpuTmxkRDBpTVNJZ2MzUnZjQzFqYjJ4dmNqMGlJMFE0TWpVMU1DSXZQand2YkdsdVpXRnlSM0poWkdsbGJuUStQR3hwYm1WaGNrZHlZV1JwWlc1MElHbGtQU0p3WVdsdWRETmZiR2x1WldGeVh6STFORjh5TmpjNUlpQjRNVDBpTWprdU1EUTFOU0lnZVRFOUlqSTRMak0xTXpNaUlIZ3lQU0l4TlRjdU56Y3pJaUI1TWowaU1qZ3VNelV6TXlJZ1ozSmhaR2xsYm5SVmJtbDBjejBpZFhObGNsTndZV05sVDI1VmMyVWlQanh6ZEc5d0lITjBiM0F0WTI5c2IzSTlJaU5HUTBRME5VWWlMejQ4YzNSdmNDQnZabVp6WlhROUlqRWlJSE4wYjNBdFkyOXNiM0k5SWlOR1JqaEVOallpTHo0OEwyeHBibVZoY2tkeVlXUnBaVzUwUGp4c2FXNWxZWEpIY21Ga2FXVnVkQ0JwWkQwaWNHRnBiblEwWDJ4cGJtVmhjbDh5TlRSZk1qWTNPU0lnZURFOUlqRXdNeTR3TXpNaUlIa3hQU0k0TGpJMUlpQjRNajBpTVRneUxqQTNOU0lnZVRJOUlqZ3VNalVpSUdkeVlXUnBaVzUwVlc1cGRITTlJblZ6WlhKVGNHRmpaVTl1VlhObElqNDhjM1J2Y0NCemRHOXdMV052Ykc5eVBTSWpOalJDUVRSRElpOCtQSE4wYjNBZ2IyWm1jMlYwUFNJeElpQnpkRzl3TFdOdmJHOXlQU0lqTVRnMlFUUTBJaTgrUEM5c2FXNWxZWEpIY21Ga2FXVnVkRDQ4TDJSbFpuTStQQzl6ZG1jK1BDOW5QaUE4WnlCemRIbHNaVDBpZEhKaGJuTm1iM0p0T25SeVlXNXpiR0YwWlNneU9YQjRMQ0F6TXpSd2VDa2lQanh5WldOMElIZHBaSFJvUFNJMk0zQjRJaUJvWldsbmFIUTlJakkyY0hnaUlISjRQU0k0Y0hnaUlISjVQU0k0Y0hnaUlHWnBiR3c5SW5KblltRW9NQ3d3TERBc01DNDJLU0lnTHo0OGRHVjRkQ0I0UFNJeE1uQjRJaUI1UFNJeE4zQjRJaUJtYjI1MExXWmhiV2xzZVQwaUowTnZkWEpwWlhJZ1RtVjNKeXdnYlc5dWIzTndZV05sSWlCbWIyNTBMWE5wZW1VOUlqRXljSGdpSUdacGJHdzlJbmRvYVhSbElqNDhkSE53WVc0Z1ptbHNiRDBpY21kaVlTZ3lOVFVzTWpVMUxESTFOU3d3TGpZcElqNUpSRG9nUEM5MGMzQmhiajR4UEM5MFpYaDBQand2Wno0Z1BHY2djM1I1YkdVOUluUnlZVzV6Wm05eWJUcDBjbUZ1YzJ4aGRHVW9Namx3ZUN3Z016WTBjSGdwSWo0OGNtVmpkQ0IzYVdSMGFEMGlNVE16Y0hnaUlHaGxhV2RvZEQwaU1qWndlQ0lnY25nOUlqaHdlQ0lnY25rOUlqaHdlQ0lnWm1sc2JEMGljbWRpWVNnd0xEQXNNQ3d3TGpZcElpQXZQangwWlhoMElIZzlJakV5Y0hnaUlIazlJakUzY0hnaUlHWnZiblF0Wm1GdGFXeDVQU0luUTI5MWNtbGxjaUJPWlhjbkxDQnRiMjV2YzNCaFkyVWlJR1p2Ym5RdGMybDZaVDBpTVRKd2VDSWdabWxzYkQwaWQyaHBkR1VpUGp4MGMzQmhiaUJtYVd4c1BTSnlaMkpoS0RJMU5Td3lOVFVzTWpVMUxEQXVOaWtpUGxCc1lYUm1iM0p0T2lBOEwzUnpjR0Z1UGxabGJtMXZQQzkwWlhoMFBqd3ZaejQ4TDNOMlp6ND0ifQ==";
        assertEq(tokenURI, expectedTokenURI);
    }

    function test_MintTwoSameIdHash() public {
        vm.startPrank(address(1));
        proofOfP2PNFTV2Venmo.mintSBT();
        vm.stopPrank();

        // Register user 0x2 with same ID Hash
        ramp.setAccountInfo(
            address(2),
            IRamp.AccountInfo({
                venmoIdHash: bytes32(0x0741728e3aae72eda484e8ccbf00f843c38eae9c399b9bd7fb2b5ee7a055b6bf),
                deposits: new uint256[](0)
            })
        );
        vm.startPrank(address(2));
        proofOfP2PNFTV2Venmo.mintSBT();
        vm.stopPrank();
        
        uint256 currTokenId = proofOfP2PNFTV2Venmo.currentTokenId();
        assertEq(currTokenId, 2);

        address ownerOne = proofOfP2PNFTV2Venmo.ownerOf(1);
        assertEq(ownerOne, address(1));

        uint256 balanceOne = proofOfP2PNFTV2Venmo.balanceOf(address(1));
        assertEq(balanceOne, 1);

        uint256 mintedOne = proofOfP2PNFTV2Venmo.getTokenId(address(1));
        assertEq(mintedOne, 1);

        address ownerTwo = proofOfP2PNFTV2Venmo.ownerOf(2);
        assertEq(ownerTwo, address(2));

        uint256 balanceTwo = proofOfP2PNFTV2Venmo.balanceOf(address(2));
        assertEq(balanceTwo, 1);

        uint256 mintedTwo = proofOfP2PNFTV2Venmo.getTokenId(address(2));
        assertEq(mintedTwo, 2);
    }

    function test_MintTwoDifferentIdHash() public {
        vm.startPrank(address(1));
        proofOfP2PNFTV2Venmo.mintSBT();
        vm.stopPrank();

        // Register user 0x2
        ramp.setAccountInfo(
            address(2),
            IRamp.AccountInfo({
                venmoIdHash: bytes32(uint256(2)),
                deposits: new uint256[](0)
            })
        );
        vm.startPrank(address(2));
        proofOfP2PNFTV2Venmo.mintSBT();
        vm.stopPrank();
        
        uint256 currTokenId = proofOfP2PNFTV2Venmo.currentTokenId();
        assertEq(currTokenId, 2);

        address ownerOne = proofOfP2PNFTV2Venmo.ownerOf(1);
        assertEq(ownerOne, address(1));

        uint256 balanceOne = proofOfP2PNFTV2Venmo.balanceOf(address(1));
        assertEq(balanceOne, 1);

        uint256 mintedOne = proofOfP2PNFTV2Venmo.getTokenId(address(1));
        assertEq(mintedOne, 1);

        address ownerTwo = proofOfP2PNFTV2Venmo.ownerOf(2);
        assertEq(ownerTwo, address(2));

        uint256 balanceTwo = proofOfP2PNFTV2Venmo.balanceOf(address(2));
        assertEq(balanceTwo, 1);

        uint256 mintedTwo = proofOfP2PNFTV2Venmo.getTokenId(address(2));
        assertEq(mintedTwo, 2);
    }

    function test_RevertMintNotRegistered() public {
        vm.startPrank(address(0xd3ad));
        vm.expectRevert("Not registered");
        proofOfP2PNFTV2Venmo.mintSBT();
        vm.stopPrank();
    }

    function test_RevertMintNullified() public {
        vm.startPrank(address(1));
        proofOfP2PNFTV2Venmo.mintSBT();
        vm.expectRevert("Already minted for owner");
        proofOfP2PNFTV2Venmo.mintSBT();
        vm.stopPrank();
    }

    function test_RevertTransfers() public {
        vm.startPrank(address(1));
        proofOfP2PNFTV2Venmo.mintSBT();
        
        vm.expectRevert("ERC721 public transferFrom not allowed");
        proofOfP2PNFTV2Venmo.transferFrom(address(1), address(2), 1);

        vm.expectRevert("ERC721 public safeTransferFrom not allowed");
        proofOfP2PNFTV2Venmo.safeTransferFrom(address(1), address(2), 1);

        vm.expectRevert("ERC721 public safeTransferFrom not allowed");
        proofOfP2PNFTV2Venmo.safeTransferFrom(address(1), address(2), 1, "");
        vm.stopPrank();
    }
}
