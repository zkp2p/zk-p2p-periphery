// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import { Test, console2 } from "forge-std/Test.sol";
import { IRampV2 } from "../src/interfaces/IRampV2.sol";
import { MockRampV2 } from "../src/mocks/MockRampV2.sol";
import { ProofOfUpiNFTV1 } from "../src/ProofOfUpiNFTV1.sol";

contract ProofOfUpiNFTV1Test is Test {
    ProofOfUpiNFTV1 public proofOfUpiNFTV1;
    MockRampV2 public ramp;

    function setUp() public {
        ramp = new MockRampV2();

        // Register user 0x1
        ramp.setAccountInfo(
            address(1),
            IRampV2.AccountInfo({
                idHash: bytes32(0x0741728e3aae72eda484e8ccbf00f843c38eae9c399b9bd7fb2b5ee7a055b6bf),
                deposits: new uint256[](0)
            })
        );

        proofOfUpiNFTV1 = new ProofOfUpiNFTV1(ramp);
    }
    
    function test_Mint() public {
        uint256 prevMinted = proofOfUpiNFTV1.getTokenId(address(1));
        assertEq(prevMinted, 0);

        vm.startPrank(address(1));
        proofOfUpiNFTV1.mintSBT();
        vm.stopPrank();
        
        uint256 tokenId = proofOfUpiNFTV1.currentTokenId();
        assertEq(tokenId, 1);

        address owner = proofOfUpiNFTV1.ownerOf(tokenId);
        assertEq(owner, address(1));

        uint256 balance = proofOfUpiNFTV1.balanceOf(address(1));
        assertEq(balance, 1);

        uint256 currMinted = proofOfUpiNFTV1.getTokenId(address(1));
        assertEq(currMinted, 1);

        string memory tokenURI = proofOfUpiNFTV1.tokenURI(tokenId);
        string memory expectedTokenURI = "data:application/json;base64,eyJuYW1lIjoiUHJvb2Ygb2YgVVBJIiwgImRlc2NyaXB0aW9uIjoiVGhpcyBzb3VsYm91bmQgTkZUIHJlcHJlc2VudHMgcHJvb2YgdGhhdCB5b3UgYXJlIGEgdW5pcXVlIFVQSSB1c2VyLiBNaW50IHRoaXMgYnkgZ2VuZXJhdGluZyBhIHplcm8ga25vd2xlZGdlIHByb29mIG9mIGEgcGF5bWVudCBjb25maXJtYXRpb24gZW1haWwuIFlvdXIgaWRlbnRpZmllciBpcyBoYXNoZWQsIHNvIG5vIG9uZSBrbm93cyB3aG8geW91IGFyZSAtLSBvbmx5IHRoYXQgeW91IGFyZSBhbiB1c2VyIVxuXG5IYXNoZWQgSUQ6IDB4MDc0MTcyOGUzYWFlNzJlZGE0ODRlOGNjYmYwMGY4NDNjMzhlYWU5YzM5OWI5YmQ3ZmIyYjVlZTdhMDU1YjZiZlxuXG4iLCAiaW1hZ2UiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWprd0lpQm9aV2xuYUhROUlqUXlNQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTVNQ0EwTWpBaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlKMmgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNuUGp4a1pXWnpQanhtYVd4MFpYSWdhV1E5SW1ZeElqNDhabVZKYldGblpTQnlaWE4xYkhROUluQXdJaUI0YkdsdWF6cG9jbVZtUFNKa1lYUmhPbWx0WVdkbEwzTjJaeXQ0Yld3N1ltRnpaVFkwTEZCSVRqSmFlVUl6WVZkU01HRkVNRzVOYW10M1NubENiMXBYYkc1aFNGRTVTbnBSZVUxRFkyZGtiV3hzWkRCS2RtVkVNRzVOUTBGM1NVUkpOVTFEUVRCTmFrRnVTVWhvZEdKSE5YcFFVMlJ2WkVoU2QwOXBPSFprTTJRelRHNWpla3h0T1hsYWVUaDVUVVJCZDB3elRqSmFlV01yVUVoS2JGa3pVV2RrTW14clpFZG5PVXA2U1RWTlNFSTBTbmxDYjFwWGJHNWhTRkU1U25wUmVVMUlRalJLZVVKdFlWZDRjMUJUWTJwU2ExazFUMVJOZWtwNU9DdFFRemw2Wkcxakt5SXZQanhtWlVsdFlXZGxJSEpsYzNWc2REMGljREVpSUhoc2FXNXJPbWh5WldZOUltUmhkR0U2YVcxaFoyVXZjM1puSzNodGJEdGlZWE5sTmpRc1VFaE9NbHA1UWpOaFYxSXdZVVF3YmsxcWEzZEtlVUp2V2xkc2JtRklVVGxLZWxGNVRVTmpaMlJ0Ykd4a01FcDJaVVF3YmsxRFFYZEpSRWsxVFVOQk1FMXFRVzVKU0doMFlrYzFlbEJUWkc5a1NGSjNUMms0ZG1RelpETk1ibU42VEcwNWVWcDVPSGxOUkVGM1RETk9NbHA1WXl0UVIwNXdZMjFPYzFwVFFtcGxSREJ1VFZSQmVVcDVRbXBsVkRCdVRWUkJkMHA1UW5sUVUyTjRUV3BDZDJWRFkyZGFiV3h6WWtRd2Jra3dXa2RTYTFwSFVtbGpkbEJxZDNaak0xcHVVR2M5UFNJdlBqeG1aVWx0WVdkbElISmxjM1ZzZEQwaWNESWlJSGhzYVc1ck9taHlaV1k5SW1SaGRHRTZhVzFoWjJVdmMzWm5LM2h0YkR0aVlYTmxOalFzVUVoT01scDVRak5oVjFJd1lVUXdiazFxYTNkS2VVSnZXbGRzYm1GSVVUbEtlbEY1VFVOaloyUnRiR3hrTUVwMlpVUXdiazFEUVhkSlJFazFUVU5CTUUxcVFXNUpTR2gwWWtjMWVsQlRaRzlrU0ZKM1QyazRkbVF6WkROTWJtTjZURzA1ZVZwNU9IbE5SRUYzVEROT01scDVZeXRRUjA1d1kyMU9jMXBUUW1wbFJEQnVUV3BSTlVwNVFtcGxWREJ1VFZSQmQwcDVRbmxRVTJONFRXcENkMlZEWTJkYWJXeHpZa1F3YmtsNlJYcFBSR2QzVDBOamRsQnFkM1pqTTFwdVVHYzlQU0lnTHo0OFptVkpiV0ZuWlNCeVpYTjFiSFE5SW5BeklpQjRiR2x1YXpwb2NtVm1QU0prWVhSaE9tbHRZV2RsTDNOMlp5dDRiV3c3WW1GelpUWTBMRkJJVGpKYWVVSXpZVmRTTUdGRU1HNU5hbXQzU25sQ2IxcFhiRzVoU0ZFNVNucFJlVTFEWTJka2JXeHNaREJLZG1WRU1HNU5RMEYzU1VSSk5VMURRVEJOYWtGdVNVaG9kR0pITlhwUVUyUnZaRWhTZDA5cE9IWmtNMlF6VEc1amVreHRPWGxhZVRoNVRVUkJkMHd6VGpKYWVXTXJVRWRPY0dOdFRuTmFVMEpxWlVRd2JrNVVhMjVKUjA0MVVGTmplRTFFUVc1SlNFazVTbnBGZDAxSVFqUktlVUp0WVZkNGMxQlRZMnBOVkUwMFQwUkJORXA1T0N0UVF6bDZaRzFqS3lJZ0x6NDhabVZDYkdWdVpDQnRiMlJsUFNKdmRtVnliR0Y1SWlCcGJqMGljREFpSUdsdU1qMGljREVpSUM4K1BHWmxRbXhsYm1RZ2JXOWtaVDBpWlhoamJIVnphVzl1SWlCcGJqSTlJbkF5SWlBdlBqeG1aVUpzWlc1a0lHMXZaR1U5SW05MlpYSnNZWGtpSUdsdU1qMGljRE1pSUhKbGMzVnNkRDBpWW14bGJtUlBkWFFpSUM4K1BHWmxSMkYxYzNOcFlXNUNiSFZ5SUdsdVBTSmliR1Z1WkU5MWRDSWdjM1JrUkdWMmFXRjBhVzl1UFNJME1pSWdMejQ4TDJacGJIUmxjajRnUEdOc2FYQlFZWFJvSUdsa1BTSmpiM0p1WlhKeklqNDhjbVZqZENCM2FXUjBhRDBpTWprd0lpQm9aV2xuYUhROUlqUXlNQ0lnY25nOUlqUXlJaUJ5ZVQwaU5ESWlJQzgrUEM5amJHbHdVR0YwYUQ0OGNHRjBhQ0JwWkQwaWRHVjRkQzF3WVhSb0xXRWlJR1E5SWswME1DQXhNaUJJTWpVd0lFRXlPQ0F5T0NBd0lEQWdNU0F5TnpnZ05EQWdWak00TUNCQk1qZ2dNamdnTUNBd0lERWdNalV3SURRd09DQklOREFnUVRJNElESTRJREFnTUNBeElERXlJRE00TUNCV05EQWdRVEk0SURJNElEQWdNQ0F4SURRd0lERXlJSG9pSUM4K1BIQmhkR2dnYVdROUltMXBibWx0WVhBaUlHUTlJazB5TXpRZ05EUTBRekl6TkNBME5UY3VPVFE1SURJME1pNHlNU0EwTmpNZ01qVXpJRFEyTXlJZ0x6NDhabWxzZEdWeUlHbGtQU0owYjNBdGNtVm5hVzl1TFdKc2RYSWlQanhtWlVkaGRYTnphV0Z1UW14MWNpQnBiajBpVTI5MWNtTmxSM0poY0docFl5SWdjM1JrUkdWMmFXRjBhVzl1UFNJeU5DSWdMejQ4TDJacGJIUmxjajQ4YkdsdVpXRnlSM0poWkdsbGJuUWdhV1E5SW1keVlXUXRkWEFpSUhneFBTSXhJaUI0TWowaU1DSWdlVEU5SWpFaUlIa3lQU0l3SWo0OGMzUnZjQ0J2Wm1aelpYUTlJakF1TUNJZ2MzUnZjQzFqYjJ4dmNqMGlkMmhwZEdVaUlITjBiM0F0YjNCaFkybDBlVDBpTVNJZ0x6NDhjM1J2Y0NCdlptWnpaWFE5SWk0NUlpQnpkRzl3TFdOdmJHOXlQU0ozYUdsMFpTSWdjM1J2Y0MxdmNHRmphWFI1UFNJd0lpQXZQand2YkdsdVpXRnlSM0poWkdsbGJuUStQR3hwYm1WaGNrZHlZV1JwWlc1MElHbGtQU0puY21Ga0xXUnZkMjRpSUhneFBTSXdJaUI0TWowaU1TSWdlVEU5SWpBaUlIa3lQU0l4SWo0OGMzUnZjQ0J2Wm1aelpYUTlJakF1TUNJZ2MzUnZjQzFqYjJ4dmNqMGlkMmhwZEdVaUlITjBiM0F0YjNCaFkybDBlVDBpTVNJZ0x6NDhjM1J2Y0NCdlptWnpaWFE5SWpBdU9TSWdjM1J2Y0MxamIyeHZjajBpZDJocGRHVWlJSE4wYjNBdGIzQmhZMmwwZVQwaU1DSWdMejQ4TDJ4cGJtVmhja2R5WVdScFpXNTBQanh0WVhOcklHbGtQU0ptWVdSbExYVndJaUJ0WVhOclEyOXVkR1Z1ZEZWdWFYUnpQU0p2WW1wbFkzUkNiM1Z1WkdsdVowSnZlQ0krUEhKbFkzUWdkMmxrZEdnOUlqRWlJR2hsYVdkb2REMGlNU0lnWm1sc2JEMGlkWEpzS0NObmNtRmtMWFZ3S1NJZ0x6NDhMMjFoYzJzK1BHMWhjMnNnYVdROUltWmhaR1V0Wkc5M2JpSWdiV0Z6YTBOdmJuUmxiblJWYm1sMGN6MGliMkpxWldOMFFtOTFibVJwYm1kQ2IzZ2lQanh5WldOMElIZHBaSFJvUFNJeElpQm9aV2xuYUhROUlqRWlJR1pwYkd3OUluVnliQ2dqWjNKaFpDMWtiM2R1S1NJZ0x6NDhMMjFoYzJzK1BHMWhjMnNnYVdROUltNXZibVVpSUcxaGMydERiMjUwWlc1MFZXNXBkSE05SW05aWFtVmpkRUp2ZFc1a2FXNW5RbTk0SWo0OGNtVmpkQ0IzYVdSMGFEMGlNU0lnYUdWcFoyaDBQU0l4SWlCbWFXeHNQU0ozYUdsMFpTSWdMejQ4TDIxaGMycytQR3hwYm1WaGNrZHlZV1JwWlc1MElHbGtQU0puY21Ga0xYTjViV0p2YkNJK1BITjBiM0FnYjJabWMyVjBQU0l3TGpjaUlITjBiM0F0WTI5c2IzSTlJbmRvYVhSbElpQnpkRzl3TFc5d1lXTnBkSGs5SWpFaUlDOCtQSE4wYjNBZ2IyWm1jMlYwUFNJdU9UVWlJSE4wYjNBdFkyOXNiM0k5SW5kb2FYUmxJaUJ6ZEc5d0xXOXdZV05wZEhrOUlqQWlJQzgrUEM5c2FXNWxZWEpIY21Ga2FXVnVkRDQ4YldGemF5QnBaRDBpWm1Ga1pTMXplVzFpYjJ3aUlHMWhjMnREYjI1MFpXNTBWVzVwZEhNOUluVnpaWEpUY0dGalpVOXVWWE5sSWo0OGNtVmpkQ0IzYVdSMGFEMGlNamt3Y0hnaUlHaGxhV2RvZEQwaU1qQXdjSGdpSUdacGJHdzlJblZ5YkNnalozSmhaQzF6ZVcxaWIyd3BJaUF2UGp3dmJXRnphejQ4TDJSbFpuTStQR2NnWTJ4cGNDMXdZWFJvUFNKMWNtd29JMk52Y201bGNuTXBJajQ4Y21WamRDQm1hV3hzUFNKR1JqazVNek1pSUhnOUlqQndlQ0lnZVQwaU1IQjRJaUIzYVdSMGFEMGlNamt3Y0hnaUlHaGxhV2RvZEQwaU5ESXdjSGdpSUM4K1BISmxZM1FnYzNSNWJHVTlJbVpwYkhSbGNqb2dkWEpzS0NObU1Ta2lJSGc5SWpCd2VDSWdlVDBpTUhCNElpQjNhV1IwYUQwaU1qa3djSGdpSUdobGFXZG9kRDBpTkRJd2NIZ2lJQzgrSUR4bklITjBlV3hsUFNKbWFXeDBaWEk2ZFhKc0tDTjBiM0F0Y21WbmFXOXVMV0pzZFhJcE95QjBjbUZ1YzJadmNtMDZjMk5oYkdVb01TNDFLVHNnZEhKaGJuTm1iM0p0TFc5eWFXZHBianBqWlc1MFpYSWdkRzl3T3lJK1BISmxZM1FnWm1sc2JEMGlibTl1WlNJZ2VEMGlNSEI0SWlCNVBTSXdjSGdpSUhkcFpIUm9QU0l5T1RCd2VDSWdhR1ZwWjJoMFBTSTBNakJ3ZUNJZ0x6NDhaV3hzYVhCelpTQmplRDBpTlRBbElpQmplVDBpTUhCNElpQnllRDBpTVRnd2NIZ2lJSEo1UFNJeE1qQndlQ0lnWm1sc2JEMGlSa1k1T1RNeklpQnZjR0ZqYVhSNVBTSXdJaUF2UGp3dlp6NDhjbVZqZENCNFBTSXdJaUI1UFNJd0lpQjNhV1IwYUQwaU1qa3dJaUJvWldsbmFIUTlJalF5TUNJZ2NuZzlJalF5SWlCeWVUMGlORElpSUdacGJHdzlJbkpuWW1Fb01Dd3dMREFzTUNraUlITjBjbTlyWlQwaWNtZGlZU2d5TlRVc01qVTFMREkxTlN3d0xqSXBJaUF2UGp3dlp6NDhkR1Y0ZENCMFpYaDBMWEpsYm1SbGNtbHVaejBpYjNCMGFXMXBlbVZUY0dWbFpDSStQSFJsZUhSUVlYUm9JSE4wWVhKMFQyWm1jMlYwUFNJdE1UQXdKU0lnWm1sc2JEMGlkMmhwZEdVaUlHWnZiblF0Wm1GdGFXeDVQU0luUTI5MWNtbGxjaUJPWlhjbkxDQnRiMjV2YzNCaFkyVWlJR1p2Ym5RdGMybDZaVDBpTVRCd2VDSWdlR3hwYm1zNmFISmxaajBpSTNSbGVIUXRjR0YwYUMxaElqNUlZWE5vSU9LQW9pQXdlREEzTkRFM01qaGxNMkZoWlRjeVpXUmhORGcwWlRoalkySm1NREJtT0RRell6TTRaV0ZsT1dNek9UbGlPV0prTjJaaU1tSTFaV1UzWVRBMU5XSTJZbVlnUEdGdWFXMWhkR1VnWVdSa2FYUnBkbVU5SW5OMWJTSWdZWFIwY21saWRYUmxUbUZ0WlQwaWMzUmhjblJQWm1aelpYUWlJR1p5YjIwOUlqQWxJaUIwYnowaU1UQXdKU0lnWW1WbmFXNDlJakJ6SWlCa2RYSTlJak13Y3lJZ2NtVndaV0YwUTI5MWJuUTlJbWx1WkdWbWFXNXBkR1VpSUM4K1BDOTBaWGgwVUdGMGFENGdQSFJsZUhSUVlYUm9JSE4wWVhKMFQyWm1jMlYwUFNJd0pTSWdabWxzYkQwaWQyaHBkR1VpSUdadmJuUXRabUZ0YVd4NVBTSW5RMjkxY21sbGNpQk9aWGNuTENCdGIyNXZjM0JoWTJVaUlHWnZiblF0YzJsNlpUMGlNVEJ3ZUNJZ2VHeHBibXM2YUhKbFpqMGlJM1JsZUhRdGNHRjBhQzFoSWo1SVlYTm9JT0tBb2lBd2VEQTNOREUzTWpobE0yRmhaVGN5WldSaE5EZzBaVGhqWTJKbU1EQm1PRFF6WXpNNFpXRmxPV016T1RsaU9XSmtOMlppTW1JMVpXVTNZVEExTldJMlltWWdQR0Z1YVcxaGRHVWdZV1JrYVhScGRtVTlJbk4xYlNJZ1lYUjBjbWxpZFhSbFRtRnRaVDBpYzNSaGNuUlBabVp6WlhRaUlHWnliMjA5SWpBbElpQjBiejBpTVRBd0pTSWdZbVZuYVc0OUlqQnpJaUJrZFhJOUlqTXdjeUlnY21Wd1pXRjBRMjkxYm5ROUltbHVaR1ZtYVc1cGRHVWlJQzgrSUR3dmRHVjRkRkJoZEdnK1BIUmxlSFJRWVhSb0lITjBZWEowVDJabWMyVjBQU0kxTUNVaUlHWnBiR3c5SW5kb2FYUmxJaUJtYjI1MExXWmhiV2xzZVQwaUowTnZkWEpwWlhJZ1RtVjNKeXdnYlc5dWIzTndZV05sSWlCbWIyNTBMWE5wZW1VOUlqRXdjSGdpSUhoc2FXNXJPbWh5WldZOUlpTjBaWGgwTFhCaGRHZ3RZU0krVDNkdVpYSWc0b0NpSURCNE1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNU0E4WVc1cGJXRjBaU0JoWkdScGRHbDJaVDBpYzNWdElpQmhkSFJ5YVdKMWRHVk9ZVzFsUFNKemRHRnlkRTltWm5ObGRDSWdabkp2YlQwaU1DVWlJSFJ2UFNJeE1EQWxJaUJpWldkcGJqMGlNSE1pSUdSMWNqMGlNekJ6SWlCeVpYQmxZWFJEYjNWdWREMGlhVzVrWldacGJtbDBaU0lnTHo0OEwzUmxlSFJRWVhSb1BqeDBaWGgwVUdGMGFDQnpkR0Z5ZEU5bVpuTmxkRDBpTFRVd0pTSWdabWxzYkQwaWQyaHBkR1VpSUdadmJuUXRabUZ0YVd4NVBTSW5RMjkxY21sbGNpQk9aWGNuTENCdGIyNXZjM0JoWTJVaUlHWnZiblF0YzJsNlpUMGlNVEJ3ZUNJZ2VHeHBibXM2YUhKbFpqMGlJM1JsZUhRdGNHRjBhQzFoSWo1UGQyNWxjaURpZ0tJZ01IZ3dNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF4SUR4aGJtbHRZWFJsSUdGa1pHbDBhWFpsUFNKemRXMGlJR0YwZEhKcFluVjBaVTVoYldVOUluTjBZWEowVDJabWMyVjBJaUJtY205dFBTSXdKU0lnZEc4OUlqRXdNQ1VpSUdKbFoybHVQU0l3Y3lJZ1pIVnlQU0l6TUhNaUlISmxjR1ZoZEVOdmRXNTBQU0pwYm1SbFptbHVhWFJsSWlBdlBqd3ZkR1Y0ZEZCaGRHZytQQzkwWlhoMFBqeG5JSE4wZVd4bFBTSjBjbUZ1YzJadmNtMDZkSEpoYm5Oc1lYUmxLREV3TlhCNExDQTNNSEI0S1NJK1BITjJaeUIzYVdSMGFEMGlPRFVpSUdobGFXZG9kRDBpT0RVaUlIWnBaWGRDYjNnOUlqQWdNQ0F4T1RJZ01Ua3lJaUJtYVd4c1BTSnViMjVsSWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpUGp4d1lYUm9JR1E5SWsweE1UTXVOelEySURFeE9DNHpPVFpETVRFMExqQTJOeUF4TVRndU16azJJREV5TXk0MU1qRWdNVEUzTGpZeE5pQXhNamN1TXpjMklERXhOaTQ1TWpoRE1UVXhMalEzTVNBeE1URXVNVFExSURFMk9TNDBNVFlnT0RrdU16a3hNaUF4TmprdU5ERTJJRFl6TGpNMk9URkRNVFk1TGpRMk1pQXpNaTQ1TkRFeUlERTBOQzQ1TURnZ09DNHlPVFU0T1NBeE1UUXVOalkwSURndU1qazFPRGxETVRFMExqTTBNaUE0TGpJNU5UZzVJREV4TkM0d05qY2dPQzR5T1RVNE9TQXhNVE11TnpRMklEZ3VNamsxT0RsSU1URTBMalkyTkVneE1UWXVOekk1UXpFeE5TNDBPU0E0TGpJNU5UZzVJREV4TkM0eU9UY2dPQzR5TlNBeE1UTXVNREV4SURndU1qVklOVEl1TmpZd05FTXpOaTR5TXpBeklEZ3VNalVnTWpJdU9EYzFJREl4TGpZd05UTWdNakl1T0RjMUlETTRMakF6TlRSV01UVTRMakl6TTBNeU1pNDROelVnTVRjeUxqTXlNaUF6TkM0ek1ESTNJREU0TXk0M05TQTBPQzR6T1RJeklERTRNeTQzTlVNMk5DNHpOak0xSURFNE15NDNOU0EzTnk0ek5URTJJREUzTUM0NE1EZ2dOemN1TXpVeE5pQXhOVFF1TnpreFZqRXlNeTR4TmpsRE56Y3VNelV4TmlBeE1qQXVOalExSURjNUxqUXhOamdnTVRFNExqVTRJRGd4TGprME1TQXhNVGd1TlRoSU1UQTNMakEwTlVNeE1Ea3VOelV6SURFeE9DNDFPQ0F4TVRNdU56UTJJREV4T0M0ek5URWdNVEV6TGpjME5pQXhNVGd1TXpVeFZqRXhPQzR6T1RaYUlpQm1hV3hzUFNKMWNtd29JM0JoYVc1ME1GOXNhVzVsWVhKZk1qVTBYekkyTnprcElpOCtQSEJoZEdnZ1pEMGlUVEl5TGpVZ016Y3VOelUzT1V3eU15NHdNRE00SURFME5pNDJNalZETXpJdU16QXhNeUF4TVRVdU16YzJJRFV6TGpjek5pQXhNRGN1TlRReElEZzJMak01TVRrZ01URTFMall3TlVNNU15NHlOaklnTVRFM0xqVTNOU0E1T0M0Mk1qQTJJREV4T0M0eU1UY2dNVEF6TGpJNU1pQXhNVGd1TkVneE1EWXVORGs0UXpFd09TNHlNREVnTVRFNExqUWdNVEV6TGpFNE5TQXhNVGd1TVRjeElERXhNeTR4T0RVZ01URTRMakUzTVVNeE1UTXVOVEEySURFeE9DNHhOekVnTVRJeUxqazBNU0F4TVRjdU16a3lJREV5Tmk0M09EZ2dNVEUyTGpjd05VTXhNekF1TlRRMElERXhOUzQzT0RnZ01UTTBMakUyTWlBeE1UUXVORFlnTVRNM0xqVTFNU0F4TVRJdU9ERkRNVFEwTGpjNE9DQXhNRGd1T1RZeElERTFNQzQyT1RZZ01UQXpMamM0TkNBeE5UUXVOREEySURFd01DNHpNREZETVRVNUxqZzFOaUE1TkM0eU9Ua3hJREUyTkM0d01qUWdPRGN1TURVNU55QXhOall1TkRBMklEYzVMakE0TnpGRE1UWTNMalk0T0NBM015NDROak0ySURFMk9DNHpOelVnTmpndU1UTTJNaUF4TmpndU16YzFJRFl4TGprMU1EWkRNVFk0TGpNM05TQTFPUzQzTlRFeUlERTJPQzR5T0RNZ05UY3VOVGszTnlBeE5qZ3VNVFEySURVMUxqUTVRekUyTkM0M01URWdNekV1TURJeU5DQXhORFV1TXpNM0lERXhMamMzT0RJZ01USXdMamc0SURndU56VTBNVE5ETVRJd0xqQTFOU0E0TGpZMk1qUTVJREV4T1M0eU16RWdPQzQxTnpBNE5pQXhNVGd1TXpZeElEZ3VOVEkxTURSRE1URTNMalkzTkNBNExqUTNPVEl5SURFeE5pNDVPRGNnT0M0ME16TTBJREV4Tmk0eklEZ3VORE16TkVNeE1UUXVOVEV6SURndU16UXhOellnTVRFeUxqWTRNU0E0TGpJMU1ERXlJREV4TUM0NE1EUWdPQzR5TlRBeE1rZzFNaTR5TWpRMlF6TTFMamczTXpnZ09DNHlNRFF6SURJeUxqVTVNVFlnTWpFdU5ESXdNeUF5TWk0MUlETTNMamMxTnpsYUlpQm1hV3hzUFNKMWNtd29JM0JoYVc1ME1WOXNhVzVsWVhKZk1qVTBYekkyTnprcElpOCtQSEJoZEdnZ1pEMGlUVEV3Tmk0Mk5qY2dPVGt1TXpZeU9FTXhNakF1T0RBMElERXdNeTQwTlRVZ01UTXhMalUwTXlBeE1EVXVNREEzSURFek9TNDRNemtnTVRBMUxqQXdOME14TkRRdU9EWTBJREV3TlM0d01EY2dNVFE0TGprNE9DQXhNRFF1TkRNMklERTFNaTQwTWpNZ01UQXpMalV4TTBNeE5qSXVPVE00SURrekxqUTFOeklnTVRZNUxqVWdOemt1TWpZeE15QXhOamt1TlNBMk15NDFNak0zUXpFMk9TNDFNRFVnTXpNdU1ETXdNU0F4TkRRdU9UQXhJRGd1TXpBNE5qZ2dNVEUwTGpVMU55QTRMak13T0RZNFF6RXhOQzR5TlRNZ09DNHpNRGcyT0NBeE1UTXVPVFE1SURndU16RTBNRElnTVRFekxqWTBOU0E0TGpNeE9UTTFWamd1TXpBNE5qaElNVEUyTGpZMU5FTXhNVFV1TkRNeUlEZ3VNamN4TXpRZ01URTBMakU0T1NBNExqSTFJREV4TWk0NU15QTRMakkxU0RVeUxqTTNORGhETXpVdU9EYzBNeUE0TGpJMUlESXlMalVnTWpFdU5qSTBNeUF5TWk0MUlETTRMakV5TkRoV09Ua3VNVEF4TkVNME1pNDFNemMxSURjMkxqTTRNRFVnTnpNdU5qZzNNeUE0Tnk0MU16VTJJREV3Tmk0Mk5qY2dPVGt1TXpZeU9Gb2lJR1pwYkd3OUluVnliQ2dqY0dGcGJuUXlYMnhwYm1WaGNsOHlOVFJmTWpZM09Ta2lMejQ4Y0dGMGFDQmtQU0pOTVRBMkxqUTROU0ExTUM0eU5USTVRekV5TUM0MU9ESWdOVFF1TXpJMU1TQXhNekV1TWpneElEVTFMamc0TURnZ01UTTVMalU1TWlBMU5TNDRPREE0UXpFMU5DNDVOelFnTlRVdU9EZ3dPQ0F4TmpFdU9UQTRJRFV3TGpVM016SWdNVFkyTGpVZ05EWXVNakkyTlVNeE5Ua3VNek0zSURJMExqSXhPRFFnTVRNNExqWTNNeUE0TGpJNU5UYzFJREV4TkM0ek16Y2dPQzR5T1RVM05VTXhNVFF1TURFMUlEZ3VNamsxTnpVZ01URXpMamMwSURndU1qazFOelVnTVRFekxqUXhPQ0E0TGpJNU5UYzFTREV4TkM0ek16ZElNVEUyTGpRd00wTXhNVFV1TVRZeklEZ3VNamsxTnpVZ01URXpMamsyT1NBNExqSTFJREV4TWk0Mk9EUWdPQzR5TlVnMU1pNHpNREZETXpVdU9EWXlNaUE0TGpJMUlESXlMalVnTWpFdU5UWTBOeUF5TWk0MUlETTNMamswTkRsV05UQXVNREkwTWtNME1pNDBOelExSURJM0xqUXlNVE1nTnpNdU5UWXhNaUF6T0M0MU16azNJREV3Tmk0ME9EVWdOVEF1TWprNE4xWTFNQzR5TlRJNVdpSWdabWxzYkQwaWRYSnNLQ053WVdsdWRETmZiR2x1WldGeVh6STFORjh5TmpjNUtTSXZQanh3WVhSb0lHUTlJazB4TURjdU5qSXhJREl4TGpRek16UkRNVEl4TGpReU55QXlOUzQwTmpVMElERXpNUzQ1TURVZ01qY3VNREExTnlBeE5EQXVNRFExSURJM0xqQXdOVGRETVRRMUxqZ3dNaUF5Tnk0d01EVTNJREUxTUM0eU5UUWdNall1TVRrd015QXhOVE11T1RReUlESTFMakF4TWpSRE1UUTFMall5TWlBeE5pNHlOamc0SURFek5DNDFNVFFnTVRBdU1qZzROeUF4TWpFdU9UWTNJRGd1TnpRNE16UkRNVEl4TGpFMU55QTRMalkxTnpjeklERXlNQzR6TkRnZ09DNDFOamN4TXlBeE1Ua3VORGt6SURndU5USXhPREpETVRFNExqZ3hPU0E0TGpRM05qVXlJREV4T0M0eE5EUWdPQzQwTXpFeU1TQXhNVGN1TkRZNUlEZ3VORE14TWpGRE1URTFMamN4TmlBNExqTTBNRFl4SURFeE15NDVNVGNnT0M0eU5TQXhNVEl1TURjeklEZ3VNalZJTlRRdU5UVXpOVU0xTXk0M05EUWdPQzR5TlNBMU1pNDVNelExSURndU1qazFNeUExTWk0eE1qVWdPQzR6T0RVNU1VTTJPQzQxTXprNElEY3VNemc1TWpNZ09EY3VOelF5T1NBeE5DNHlOelUwSURFd055NDJNakVnTWpFdU5EYzROMVl5TVM0ME16TTBXaUlnWm1sc2JEMGlkWEpzS0NOd1lXbHVkRFJmYkdsdVpXRnlYekkxTkY4eU5qYzVLU0l2UGp4a1pXWnpQanhzYVc1bFlYSkhjbUZrYVdWdWRDQnBaRDBpY0dGcGJuUXdYMnhwYm1WaGNsOHlOVFJmTWpZM09TSWdlREU5SWpJeUxqZzNOU0lnZVRFOUlqZzBMamcxTURnaUlIZ3lQU0l4TmprdU5ERTJJaUI1TWowaU9EUXVPRFV3T0NJZ1ozSmhaR2xsYm5SVmJtbDBjejBpZFhObGNsTndZV05sVDI1VmMyVWlQanh6ZEc5d0lITjBiM0F0WTI5c2IzSTlJaU0wTURVM1EwSWlMejQ4YzNSdmNDQnZabVp6WlhROUlqQXVNVGsyT1RjaUlITjBiM0F0WTI5c2IzSTlJaU16UXpOQk9VWWlMejQ4YzNSdmNDQnZabVp6WlhROUlqQXVOVFExTkRVMUlpQnpkRzl3TFdOdmJHOXlQU0lqTkRReE5UY3hJaTgrUEhOMGIzQWdiMlptYzJWMFBTSXhJaUJ6ZEc5d0xXTnZiRzl5UFNJak1qZ3hRek5CSWk4K1BDOXNhVzVsWVhKSGNtRmthV1Z1ZEQ0OGJHbHVaV0Z5UjNKaFpHbGxiblFnYVdROUluQmhhVzUwTVY5c2FXNWxZWEpmTWpVMFh6STJOemtpSUhneFBTSXlPQzR3TWpVMklpQjVNVDBpTmpRdU5qTTBJaUI0TWowaU1UY3pMamt3TVNJZ2VUSTlJalkwTGpZek5DSWdaM0poWkdsbGJuUlZibWwwY3owaWRYTmxjbE53WVdObFQyNVZjMlVpUGp4emRHOXdJSE4wYjNBdFkyOXNiM0k5SWlNM09ERkROMEVpTHo0OGMzUnZjQ0J2Wm1aelpYUTlJakVpSUhOMGIzQXRZMjlzYjNJOUlpTTFOVEUyTnpFaUx6NDhMMnhwYm1WaGNrZHlZV1JwWlc1MFBqeHNhVzVsWVhKSGNtRmthV1Z1ZENCcFpEMGljR0ZwYm5ReVgyeHBibVZoY2w4eU5UUmZNalkzT1NJZ2VERTlJakl5TGpVaUlIa3hQU0kyT1M0d05qWTFJaUI0TWowaU1UWTVMamMwSWlCNU1qMGlOamt1TURZMk5TSWdaM0poWkdsbGJuUlZibWwwY3owaWRYTmxjbE53WVdObFQyNVZjMlVpUGp4emRHOXdJRzltWm5ObGREMGlNQzR4TlRrME1pSWdjM1J2Y0MxamIyeHZjajBpSTBaRk9FRTJOeUl2UGp4emRHOXdJRzltWm5ObGREMGlNU0lnYzNSdmNDMWpiMnh2Y2owaUkwUTRNalUxTUNJdlBqd3ZiR2x1WldGeVIzSmhaR2xsYm5RK1BHeHBibVZoY2tkeVlXUnBaVzUwSUdsa1BTSndZV2x1ZEROZmJHbHVaV0Z5WHpJMU5GOHlOamM1SWlCNE1UMGlNamt1TURRMU5TSWdlVEU5SWpJNExqTTFNek1pSUhneVBTSXhOVGN1TnpjeklpQjVNajBpTWpndU16VXpNeUlnWjNKaFpHbGxiblJWYm1sMGN6MGlkWE5sY2xOd1lXTmxUMjVWYzJVaVBqeHpkRzl3SUhOMGIzQXRZMjlzYjNJOUlpTkdRMFEwTlVZaUx6NDhjM1J2Y0NCdlptWnpaWFE5SWpFaUlITjBiM0F0WTI5c2IzSTlJaU5HUmpoRU5qWWlMejQ4TDJ4cGJtVmhja2R5WVdScFpXNTBQanhzYVc1bFlYSkhjbUZrYVdWdWRDQnBaRDBpY0dGcGJuUTBYMnhwYm1WaGNsOHlOVFJmTWpZM09TSWdlREU5SWpFd015NHdNek1pSUhreFBTSTRMakkxSWlCNE1qMGlNVGd5TGpBM05TSWdlVEk5SWpndU1qVWlJR2R5WVdScFpXNTBWVzVwZEhNOUluVnpaWEpUY0dGalpVOXVWWE5sSWo0OGMzUnZjQ0J6ZEc5d0xXTnZiRzl5UFNJak5qUkNRVFJESWk4K1BITjBiM0FnYjJabWMyVjBQU0l4SWlCemRHOXdMV052Ykc5eVBTSWpNVGcyUVRRMElpOCtQQzlzYVc1bFlYSkhjbUZrYVdWdWRENDhMMlJsWm5NK1BDOXpkbWMrUEM5blBpQThaeUJ6ZEhsc1pUMGlkSEpoYm5ObWIzSnRPblJ5WVc1emJHRjBaU2d5T1hCNExDQXpNelJ3ZUNraVBqeHlaV04wSUhkcFpIUm9QU0kyTTNCNElpQm9aV2xuYUhROUlqSTJjSGdpSUhKNFBTSTRjSGdpSUhKNVBTSTRjSGdpSUdacGJHdzlJbkpuWW1Fb01Dd3dMREFzTUM0MktTSWdMejQ4ZEdWNGRDQjRQU0l4TW5CNElpQjVQU0l4TjNCNElpQm1iMjUwTFdaaGJXbHNlVDBpSjBOdmRYSnBaWElnVG1WM0p5d2diVzl1YjNOd1lXTmxJaUJtYjI1MExYTnBlbVU5SWpFeWNIZ2lJR1pwYkd3OUluZG9hWFJsSWo0OGRITndZVzRnWm1sc2JEMGljbWRpWVNneU5UVXNNalUxTERJMU5Td3dMallwSWo1SlJEb2dQQzkwYzNCaGJqNHhQQzkwWlhoMFBqd3ZaejRnUEdjZ2MzUjViR1U5SW5SeVlXNXpabTl5YlRwMGNtRnVjMnhoZEdVb01qbHdlQ3dnTXpZMGNIZ3BJajQ4Y21WamRDQjNhV1IwYUQwaU1URTVjSGdpSUdobGFXZG9kRDBpTWpad2VDSWdjbmc5SWpod2VDSWdjbms5SWpod2VDSWdabWxzYkQwaWNtZGlZU2d3TERBc01Dd3dMallwSWlBdlBqeDBaWGgwSUhnOUlqRXljSGdpSUhrOUlqRTNjSGdpSUdadmJuUXRabUZ0YVd4NVBTSW5RMjkxY21sbGNpQk9aWGNuTENCdGIyNXZjM0JoWTJVaUlHWnZiblF0YzJsNlpUMGlNVEp3ZUNJZ1ptbHNiRDBpZDJocGRHVWlQangwYzNCaGJpQm1hV3hzUFNKeVoySmhLREkxTlN3eU5UVXNNalUxTERBdU5pa2lQbEJzWVhSbWIzSnRPaUE4TDNSemNHRnVQbFZRU1R3dmRHVjRkRDQ4TDJjK1BDOXpkbWMrIn0=";
        assertEq(tokenURI, expectedTokenURI);
    }

    function test_MintTwoSameIdHash() public {
        vm.startPrank(address(1));
        proofOfUpiNFTV1.mintSBT();
        vm.stopPrank();

        // Register user 0x2 with same ID Hash
        ramp.setAccountInfo(
            address(2),
            IRampV2.AccountInfo({
                idHash: bytes32(0x0741728e3aae72eda484e8ccbf00f843c38eae9c399b9bd7fb2b5ee7a055b6bf),
                deposits: new uint256[](0)
            })
        );
        vm.startPrank(address(2));
        proofOfUpiNFTV1.mintSBT();
        vm.stopPrank();
        
        uint256 currTokenId = proofOfUpiNFTV1.currentTokenId();
        assertEq(currTokenId, 2);

        address ownerOne = proofOfUpiNFTV1.ownerOf(1);
        assertEq(ownerOne, address(1));

        uint256 balanceOne = proofOfUpiNFTV1.balanceOf(address(1));
        assertEq(balanceOne, 1);

        uint256 mintedOne = proofOfUpiNFTV1.getTokenId(address(1));
        assertEq(mintedOne, 1);

        address ownerTwo = proofOfUpiNFTV1.ownerOf(2);
        assertEq(ownerTwo, address(2));

        uint256 balanceTwo = proofOfUpiNFTV1.balanceOf(address(2));
        assertEq(balanceTwo, 1);

        uint256 mintedTwo = proofOfUpiNFTV1.getTokenId(address(2));
        assertEq(mintedTwo, 2);
    }

    function test_MintTwoDifferentIdHash() public {
        vm.startPrank(address(1));
        proofOfUpiNFTV1.mintSBT();
        vm.stopPrank();

        // Register user 0x2
        ramp.setAccountInfo(
            address(2),
            IRampV2.AccountInfo({
                idHash: bytes32(uint256(2)),
                deposits: new uint256[](0)
            })
        );
        vm.startPrank(address(2));
        proofOfUpiNFTV1.mintSBT();
        vm.stopPrank();
        
        uint256 currTokenId = proofOfUpiNFTV1.currentTokenId();
        assertEq(currTokenId, 2);

        address ownerOne = proofOfUpiNFTV1.ownerOf(1);
        assertEq(ownerOne, address(1));

        uint256 balanceOne = proofOfUpiNFTV1.balanceOf(address(1));
        assertEq(balanceOne, 1);

        uint256 mintedOne = proofOfUpiNFTV1.getTokenId(address(1));
        assertEq(mintedOne, 1);

        address ownerTwo = proofOfUpiNFTV1.ownerOf(2);
        assertEq(ownerTwo, address(2));

        uint256 balanceTwo = proofOfUpiNFTV1.balanceOf(address(2));
        assertEq(balanceTwo, 1);

        uint256 mintedTwo = proofOfUpiNFTV1.getTokenId(address(2));
        assertEq(mintedTwo, 2);
    }

    function test_RevertMintNotRegistered() public {
        vm.startPrank(address(0xd3ad));
        vm.expectRevert("Not registered");
        proofOfUpiNFTV1.mintSBT();
        vm.stopPrank();
    }

    function test_RevertMintNullified() public {
        vm.startPrank(address(1));
        proofOfUpiNFTV1.mintSBT();
        vm.expectRevert("Already minted for owner");
        proofOfUpiNFTV1.mintSBT();
        vm.stopPrank();
    }

    function test_RevertTransfers() public {
        vm.startPrank(address(1));
        proofOfUpiNFTV1.mintSBT();
        
        vm.expectRevert("ERC721 public transferFrom not allowed");
        proofOfUpiNFTV1.transferFrom(address(1), address(2), 1);

        vm.expectRevert("ERC721 public safeTransferFrom not allowed");
        proofOfUpiNFTV1.safeTransferFrom(address(1), address(2), 1);

        vm.expectRevert("ERC721 public safeTransferFrom not allowed");
        proofOfUpiNFTV1.safeTransferFrom(address(1), address(2), 1, "");
        vm.stopPrank();
    }
}
